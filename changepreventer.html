<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Change Preventer</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Header -->
    <div id="nav-id">
        <div class="nav-link text" id="title-id">
            <a href="index.html">Code Reengineering</a>
        </div>
        <div class="nav-link text" id="nav-button-id">
            <a class="active" href="changepreventer.html">Change Preventer</a>
            <a href="dispensables.html">Dispensables</a>
        </div>
    </div>

    <!-- Content -->
    <div id="content-cp">
        <div class="text" id="background">
            <h1>Change Preventer</h1>
        </div>
    </div>
    <div class="text cp-box">
        <h1>Divergent Change</h1>
        <p>Divergent Change adalah sebuah smell code dimana terjadinya banyak perubahan method yang dibuat terhadap salah satu class. Akibatnya, class tersebut terbebani dengan method method yang terlalu banyak yang dapat mengakibatkan munculnya bug atau error yang fatal. <span>Solusi: </span>memisahkan method tersebut dengan extract class.
            Jika di dalam beberapa kelas terdapat method yang sama dapat dijadikan menjadi satu dengan proses inheritance (extract superclass atau subclass)</p>
        <p style="color: red; font-size: 1.4vw;">Before</p>
        <img src="assets\Divergentbefore.png" alt="">
        <p style="color: lime; font-size: 1.4vw;">After</p>
        <img src="assets/Divergentafter.png" alt="">
        <p>Pada code diatas, class ShoppingCart bertanggung jawab untuk fungsi mengelola barang keranjang dan pembayaran. alhasil , ketika terjadi perubahan di fitur pembayaran, kita juga harus merubah code di class ShoppingCart. Untuk menghindari hal tersebut, kita dapat melakukan refactoring dengan metode extract class dimana fungsi pembayaran tersebut dipindahkan menjadi class tersendiri.</p>
    </div>
    <div class="text cp-box">
        <h1>Shotgun Surgery</h1>
        <p>Shotgun Surgery adalah sebuah smell code dimana terjadinya perubahan method atau function di berbagai class untuk menyelesaikan satu fitur.<span>Solusi: </span>Menggunakan move method atau move field untuk memindahkan method yang sama ke class yang baru.
        </p>
        <p style="color: red; font-size: 1.4vw;">Before</p>
        <img src="assets/SGbefore.png" alt="">
        <p style="color: lime; font-size: 1.4vw;">After</p>
        <img src="assets\SGafter.png" alt="">
        <p>Dalam contoh di atas, ketiga metode update Availability, updatePrice, dan updateName bertanggung jawab untuk memperbarui atribut-atribut yang berbeda dari objek Product. Jika kita ingin mengubah bagaimana atribut-atribut ini diperbarui, kita harus mengubah semua metode ini, yang tersebar di seluruh kode.</p>
    </div>
    <div class="text cp-box">
        <h1>Parallel Inheritance Hierarchies</h1>
        <p>Parallel Inheritance Hierarchies adalah sebuah smell code dimana ketika kita membuat sebuah subclass A, kita juga harus membuat subclass B. Hal ini dapat mengakibatkan struktur codebase yang rumit untuk dikelola.<span>Solusi: </span>Pertama, buatlah subclass dari satu hirarki merujuk kepada subclass dari hirarki yang lain. Kemudian, hapuslah hirarki dalam kelas yang dirujuk, dengan menggunakan Move Method dan Move Field.
        </p>
        <p style="color: red; font-size: 1.4vw;">Before</p>
        <img src="assets\Paralelbefore.png" alt="">
        <p style="color: lime; font-size: 1.4vw;">After</p>
        <img src="assets\Paralelafter.png" alt="">
        <p>Dalam contoh di atas, kita memiliki dua hierarki kelas yang terpisah: satu untuk hewan dan satu lagi untuk kendaraan. Namun, jika kita memperkenalkan sub-kategori seperti hewan yang dapat mengendarai kendaraan (misalnya, anjing yang dapat mengendarai mobil), kita akan menghadapi kesulitan. Kita mungkin harus menambahkan kelas baru seperti DogCar, yang akan menjadi bagian dari kedua hierarki.</p>
    </div>

    <!-- Footer -->
    <div class="text" id="footer">
        <p>©Copyright 2024 <span>TimCR</span>. All Rights Reserved syarat dan ketentuan user</p>
    </div>
</body>
</html>